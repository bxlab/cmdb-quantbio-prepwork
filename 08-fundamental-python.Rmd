```{r, include = FALSE}
ottrpal::set_knitr_image_path()
library(reticulate)
```

## Learning Objectives

* Differentiate between the fundamental data types and structures in Python
* Use variable assignment to store data/information within named variables
* Demonstrate how to open files for Python to read data from
* Describe the use of conditionals to make choices within scripts
* Explain what iterating is and how `for` loops are used 

## Resources

* [Object-Oriented Programming in Python is freely available documentation on programming in Python](https://python-textbok.readthedocs.io/en/1.0/index.html) and provides examples and thorough descriptions of fundamentals in Python programming. The table of contents is fairly well organized and has a lot of the buzz words contained in this module. There is more information covered in this book than will be required knowledge for you, but as a whole it likely will be a helpful resource to consult during the course.  
* [Think Python 2nd Edition is freely available as web-based book](https://greenteapress.com/thinkpython2/html/index.html) and explains lots of Python vocabulary, syntax, and operations. The table of contents is quite thorough in describing each chapter's contents. There is more information covered in this book than will be required knowledge for you, but as a whole it likely will be a helpful resource to consult during the course. This resource does not have an easy means to navigate back to the table of contents though.
* There is a [python syntax cheatsheet](http://bxlab.github.io/cmdb-bootcamp/cheatsheet/python.html) that may be useful, especially throughout the course. 
* Other website resources will be linked throughout this module for specific topics. If a resource uses terminology or functionality that you are not expected to learn, we will note it after linking the resource. 
* Use of all linked resources is optional but strongly recommended. 

## Fundamental Python vocabulary and syntax

### Data types and structures

"Data" is information -- information that you want to process or perform operations on, simplify, visualize, etc. This information must be stored within python scripts or else read in from files (`csv`, `txt`, etc.). Python stores and represents the data as different data types or within different structures. Another word for data in python is "object". You often want to explicitly make sure that the data is stored as a specific type so that you can perform specific operations on it (e.g., do specific things with or manipulate/analyze the data in a specific way). Math operations can be performed with integers or floats, but not strings. You can index with integers, but not floats, etc. Terms like these specific data types will be explained in more detail next. Terms like "index" will be explained in more detail in a few sections.

There are many data types and structures that are used in Python. 

* Integers: Integers are whole numbers 
  * These whole number are typed with just the numbers and do not include commas (`,`) or periods (`.`).
  * Examples: 
    * -2
    * 181
    * 10000056
    * 0
* Floats: Floats are numbers that have fractional or decimal parts. 
  * These are typed with numbers and do have periods (`.`) or forward slashes (`/`) in them.
  * Examples:
    * -2.5
    * 8/2
    * 79/3
* Strings: Strings are words, phrases, or just single characters that are strung together and enclosed by single (`'`) or double (`"`) quotes.
  * Examples:
    * "acgt"
    * "Banana"
    * "Hello, World!"
    * "1"
    * 'The quick brown fox jumped over the lazy Gibbs'
* Booleans: Booleans are variables that store `True` or `False`. 
  * Unlike integers,  floats, and strings which can have many possible values, data that is a boolean data type is either `True` or `False`. 
* Lists: Lists are a data structure, specifically, collections of items that are enclosed in brackets. ( `[` and `]` ).
  * In Python, lists can be homogeneous, and contain items that are all the same data type (e.g., a list of strings or a list of integers); or lists can be heterogeneous, containing items that are different data types.
  * In Python, lists are also ordered, meaning that the elements or items contained in the list have a specific position associated with them.
  * Examples:
    * [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    * ["B", "a", "n", "a", "n", "a"]
    * ["a", 1, "c", 0, "g", 1, "t", 1]
    * ["Hello,", "World!"]
    * ["The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "Gibbs"]
* Sets: Sets are another data structure, specifically, collections of unique (or non-duplicated) items that are enclosed in curly braces ( `{` and `}` ).
  * To make a list into a set, the repeated items from the list are removed. For example, the list ["B", "a", "n", "a", "n", "a"] would be the set {"B", "a", "n"}. One super cool thing is if you define your set to be {"B", "a", "n", "a"}, Python will simplify it be {"B", "n", "a"}. (Also, note this is an example of how the set is unordered.)
  * Sets are useful if you want to track all the unique elements present in a large dataset and don't care if or how many times each element is repeated.
* Dictionaries. Dictionaries are another Python data structure, specifically collections of paired key,value items that are enclosed in curly braces. ( `{` and `}` ). 
  * By paired key,values we mean that a specific key is used to reference some value. For example, in the following dictionary `dog_favorite_toys`, `"Gibbs"` is a key used to refer to the value `"football"` because his favorite toy is a squeaking football. 
```{python}
dog_favorite_toys = {"Gibbs": "football",
                     "Duke": "squirrel",
                     "Barnaby": "frisbee"}

```
  * (What previously listed data type is each of the keys and values within that dictionary? )
  * Note that the key and value in a pair are separated by a colon (`:`) and the pairs are separated from each other by a comma (`,`)
  * While sets are useful if you want to track all the unique elements present in a large dataset, but don't care if or how many times each element is repeated, dictionaries allow you to track the presence and associate further information like how many times the element is present. The key would be the element (like a gene ID), and the value would the number of times that element (gene ID) is present in the dataset. The key has to be unique within the dictionary. The values may not be unique, like multiple gene IDs may be present in the dataset the same number of times.
  
#### Data represented or stored as an unintended data types:

Note: While we know that -2 is an integer, if you represent this integer in the following ways, it is not considered an integer by Python: 
  * -2.0 or -2/1
  * "-2.0"
  
In the first case, Python considers these representations to be floats, which can still be used for mathematical operations, but couldn't be used to index. In the second case, Python considers the data to be a string, and it cannot be used in mathematical operations unless it is converted to a numerical (integer or float) data type. Examples of converting with the `int()` and `float()` functions are available in the [Python syntax cheatsheet](http://bxlab.github.io/cmdb-bootcamp/cheatsheet/python.html) that was mentioned earlier. 

Often when reading data into Python from a file, numbers will be interpreted by python as strings and need to be converted to the correct data type. 


#### Immutability

What does it mean for a data type to be immutable? It means that the value of an object with that data type cannot be changed without creating a new object. 

##### Immutable data types

* Strings
* Integer
* Float
* Boolean

All other listed data types and structures from the previous section are mutable or can be changed.

### Variables

What are variables? A Python variable is a symbolic name that is a reference to a data object. Once a data object is assigned to a variable, you can refer to the object by that name, retrieving it many times. While data objects can exist in Python without being stored in variables, you can't reference and retrieve the data repeatedly without storing it in a variable. Within Python, you can have many variables each storing different values, and you distinguish between these variables according to their names.

The variable name is set within a variable assignment statement. We use an `=` (equals sign) to store data in a specific variable, associating that variable name with the value of the data. Then the variable can be referenced throughout a script. To store data in a variable, the variable name is on the left of the equals sign, and the data is on the right, like the following pattern:

`variable_name =  "some data"`

You've already seen an example of this with the dictionary `dog_favorite_toys` above. The data we are storing is saved in a variable named dog_favorite_toys. By using variables to store data, you can reference the variable later and use or modify the data stored in the variable. Assigning a value to a variable name is also called "defining" a variable or "initializing" a variable. 

This variable assignment statement is considered an "expression" in Python. We'll discuss more expressions in the next section of this module.

Variables can be overwritten, either intentionally or unintentionally. So for an example intentionally changing a variable's value, consider that you may be looking through results of a genetic screen, wondering if a specific gene of interest was affected by the screen. You would store the gene of interest in a variable named `gene_of_interest`, and you set a boolean variable `gene_found` to `False` because you don't know if the gene of interest is in the large file. The script then looks through the file as long as the gene of interest isn't found (and `gene_found` is `False`). Once the script finds the gene of interest, you want to overwrite the `gene_found` variable or change its value to `True`.

```{python}
gene_of_interest = "DENN1B"
gene_found = False
#Lots of other code that makes the script load and look through a large file
#While looking through the file, the script finds the gene_of_interest
#Since the gene was found, overwrite the gene_found variable to be True and stop looking through the file
gene_found = True
```

For an example of unintentionally changing a variable's value, you may reuse a variable name later in a script. Then that variable will no longer reference the value which was stored earlier.

What can you name a variable? Anything? 
  * Variable names should be meaningful and provide a description of what the variable contains. (However, comments within code can be used when defining a variable to accomplish this, especially if variable names are becoming unnecessarily long.)
  * Note that while the name of the variable should be meaningful, the name doesn't matter in how Python treats the variable. I could name a variable `filename` and store an integer in it and Python will treat the variable as the numerical value it has, not a string filename like its name suggests.  
  * Variable names can contain numbers (e.g., 0, 1, 2, ...), but they cannot start with numbers. (i.e., `file1` is an acceptable variable name, but `1file` is not)
  * There are "keywords" in Python 3 that are used in expressions and have very specific functionality associated with them. They cannot be used as variable names. You don't need to memorize the list, but you [can find the list of keywords here](https://docs.python.org/3/reference/lexical_analysis.html#keywords)
  * The case of the variable is important. `myVariable` is a different variable name than `myvariable`. 
  * It is acceptable to use a combination of upper and lowercase letters in variable names as well as underscores (`_`). This can be helpful for longer variable names like `gene_of_interest`.  

### Expressions and common built-in functions

What is an operator? In python, an operator is some special symbol or keyword that designates that some specific computation should bbe performed. These include 
* arithmetic operators for addition (`+`), subtraction (`-`), division (`/`), etc.
* comparison operators for testing equality of any value as well as whether numbers are greater than, less than, or equal to other numbers (`==` )
* logical operators for boolean values (`and`, `not`, `or`, etc.).   

What is an expression? In python, an expression is some combination or sequence of values or variables and operators.  

What is a built-in function? There are common built-in functions that are available to use in Python to perform specific tasks. These functions have names which are followed by parentheses. If the function takes any arguments that affect its behavior, these are included inside the parentheses when calling or using the function. Examples of built-in functions include `print()`, `len()`, etc.

#### Testing equality

You can test whether the value of two objects are equal to one other by testing equality with a double equals sign (`==`) operator. Therefore an expression to test equality would look like the following pattern:

`variable1 == variable2`

Testing equality expressions are evaluated by Python, (i.e., Python finds the value of the expression) and return a boolean, so either `True` or `False`.

Here's an example of a testing equality expression that will be evaluated as `True`.

```{python}
3 == 3.0
```

And here's an example of a testing equality expression that will be evaluated as `False`.

```{python}
dog = "Gibbs"
dog == "dog"

```

#### `in`

You can test whether some item is contained in a list or as a dictionary key, etc. using the `in` operator. Again, an expression that contains the `in` operator will be evaluated and return either `True` or `False`.

The structure for this expression follows this pattern:

`variable in variable_for_data_structure`

```{python}
testlist = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
7 in testlist
```

```{python}
8 in testlist
```

```{python}
"Gibbs" in dog_favorite_toys
```

#### `not` or `!`

If you add `not` before `in`, you can test whether an item is not contained in some collection of items. While `7 in testlist` was False, because 7 was not in the collection of items in `testlist`, `7 not in testlist` should be True, because 7 is in fact not in the `testlist` collection.

```{python}
7 not in testlist
```

Or if you have a boolean variable `variableName` and you put `not` in front of the variable, then `not variableName` will take on the opposite value of `variableName`. Below `a` is a standin for the boolean variable.

| a | not a |
| - | ----- |
| T |   F   |
| F |   T   |

In a similar manner, while testing for equality or inequality of two variables or values, rather than using the double equals (`==`) to test for equality, you can use an exclamation point and a single equals sign (`!=`) to test if two variables or values are not equal.

And while the value of the variable `dog` didn't equal the string `"dog"`, and the expression `dog == "dog"` evaluated to False, `dog != "dog"` will evaluate to True. 

```{python}
dog != "dog"
```

#### `and`

Sometimes you need to chain expressions together to see if multiple things are True. You can use the `and` operator in between the expressions. Below the letters `a` and `b` are stand-ins for the expressions.

| a | not a | b | a and b |
| - | ----- | - | ------- |
| T |   F   | T |    T    |
| T |   F   | F |    F    |
| F |   T   | T |    F    |
| F |   T   | F |    F    |

#### `or`

Alternatively, you may chain expressions together to see if at least one is True. You can use the `or` operator in between the expressions. Below the letters `a` and `b` are stand-ins for the expressions.

| a | not a | b | a and b | a or b |
| - | ----- | - | ------- | ------ |
| T |   F   | T |    T    |    T   |
| T |   F   | F |    F    |    T   |
| F |   T   | T |    F    |    T   |
| F |   T   | F |    F    |    F   |

#### `print()`

The `print()` function is used to display formatted messages onto the screen or in a file. The function is also very useful in debugging to see what values certain variables are, their type, their length, etc when code isn't behaving as expected.

```{python}
print("Hello, World!")
```

```{python}
the_temperature_today = 88
print("The temperature outside in Baltimore today is", the_temperature_today, "degrees F.")
```

#### `open()`

In Python, you can open a file with data to read by passing the filename to the `open()` function. We will be using this function as we recreate the `head` bash tool later.

#### `len()`

Data types and structures that are collections of items (e.g., a string which is a collection of characters strung together; a list which is a collection of items, a set which is a collection of non-duplicated items, and a dictionary which is a collection of key-value pairs) have a length associated with them. This is the number of items in the collection. you can find the length of variables of these types using the Python function `len()`.

```{python}
len("acgt")
len(dog_favorite_toys)
len([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144])
```

### Conditionals

Conditional statements are used in python to check the value of a boolean variable or expression and specify what behavior or path of steps the script should follow depending on whether the boolean/expression was True or False. An example of an everyday conditional you may think through is like the following:

I am about to leave. Is it raining outside right now?
Yes --> Grab an umbrella and leave

In Python, this could look something like the following if we have the boolean variable `rainingNow`.

```{python}
rainingNow = True
if rainingNow:
  print('Grab the umbrella')
```

In the above code example, the boolean variable for whether it is currently raining is set to True, and the indented code under the `if` statement is executed.

```{python}
rainingNow = False
if rainingNow:
  print("Grab the umbrella")
```

In the same above code example, the only change is that the boolean variable for whether it is currently raining is set to False, and the indented code under the `if` statement is not executed/you don't see the print statement.

In general, when using conditional statements, the boolean values are checked and anything indented under True boolean expressions/variables wll be executed linearly by the script. In python, you can have an `if` statement ( `if booleanVariable:`) without an `else` statement. Or you can have an `if` statement followed by an `else` statement.  In that case, anything indented after the `else` statement will only be executed by the script if the value of the boolean variable is False.

```{python}
rainingNow = False
if rainingNow:
  print("Grab the umbrella")
else:
  print("Leave without the umbrella")
```

However, there may be times that there are other things to consider in addition to the initial `if` statement, things that you would want to think about when the initial if statement boolean variable or expression or condition is False. Let's extend the raining example. 

I am about to leave. Is it raining outside right now?
Yes --> Grab an umbrella and leave
No --> Will it be raining at some point while I am outside?
        Yes --> Grab an umbrella and leave
        No --> leave
        
In Python, this could look something like the following if we have the boolean variables `rainingNow` and `rainingLater`. We add an `elif` statement that will be checked if the first variable is False, but will be ignored if the first variable is True:

```{python}
rainingNow = True
rainingLater = True
if rainingNow:
  print("Grab the umbrella for now")
elif rainingLater:
  print("Grab the umbrella for later")
else:
  print("Leave without the umbrella")
```

This little code block asks if `rainingNow` is True. If it is, then the script will conclude that you should grab the umbrella, and it won't check the `elif` statement to see if that variable is True. If it is False, the script ignores what is indented under the `if rainingNow:` and will check the value of `rainingLater` variable. If that's True, the script will conclude you should grab the umbrella. But if that is also False, then, the script again ignores what is indented under the `elif rainingLater:` statement and the script goes to the else statement and concludes that you leave without the umbrella.

```{python}
rainingNow = False
rainingLater = True
if rainingNow:
  print("Grab the umbrella for now")
elif rainingLater:
  print("Grab the umbrella for later")
else:
  print("Leave without the umbrella")
```

Note here in this example how the print statements include the "for now" and "for later" phrases so we can distinguish which conditional statement was executed. Unique print statement usage is a tool you can use in debugging scripts.

Sections 5.2 - 5.7 on conditionals in the Think Python resource are especially helpful in looking at conditional statements.

### Iterating

What is iterating and why do we want it? Iterating is going through a collection of items item-by-item. You likely want to use iterating if you want to apply the same set of operations on each item, or scan through the collection of items and catalog some information about the collection. We'll see an example of use a `for` loop structure to iterate through lists in a few sections.

#### Iterable data types

Iterable data types are those which are a collection of items that can be iterated through item-by-item:

* Strings
* List
* Sets
* Dictionaries

#### Indexing

What is indexing? Indexing is a way to refer to individual elements in an ordered, iterable object (like lists or strings) by their position or location within the ordered, iterable object. An index or these positions/indices are specifically integer data types. Floats, strings, and other such data types cannot be used to index.

The indexing "operator" in python is brackets, `[]`. So like the arithmetic, comparison, and logic operators discussed earlier, the indexing operator is a special symbol(s) with a pre-determined set of behaviors associated with it. The brackets directly follow the name of whatever ordered, iterable object you wish to index, and the index position(s) you wish to extract or change are included in between the brackets. If you try to use an indexing operator to index an unordered object like a set, you will see the following error: `TypeError: 'set' object is not subscriptable`.

In Python, indexing starts from 0. So for a list of days of the week `dow = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]`, even though Sunday is the first day of the week, and the first element in the list, its position or index is 0. And Saturday, the last or 7th day of the week has an index or position of 6. If you try to index this list with a position of 1 (e.g., `dow[1]`), that position refers to Monday. And if you try to index this list with a position of 7 (e.g., `dow[7]`), you'll see the following error that says there is no index of 7 in the data structure or list `dow`: `IndexError: list index out of range`. If you want to extract an element from a list and store it in a variable, then you'd use the following pattern like we saw earlier with variable assignment: `last_day_of_week = dow[-1]`. Note that the list name, indexing operator, and index position are on the right side of the equals sign. Note that the `dow` list is unchanged compared to its original identity.

Recall that lists are mutable which means that in addition to using indexing to extract information from the list, grabbing a list element that is in a specific position, you can also use indexing to change the list and overwrite information within the list, modifying a list element that is in a specific position. Becasue of this, if you want to modify a specific list position, where would the list name, indexing operator, and index position be in relation to the equals sign in a variable assignment expression? For example, let's say that you decide to outlaw Mondays and replace them with a second Thursday, the data that you want to store in the variable is `"Thursday"` and the variable that you want to store it in is `dow` but specifically `dow` at position 1, so `dow[1]`. Then your variable assignment statement would be `dow[1] = "Thursday"` and the `dow` list is changed compared to its original identity: `['Sunday', 'Thursday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`

#### Slicing

What is slicing? Slicing is extracting a subset of elements from an interable object using a range of the positions of the desired subset of elements within the ordered,iterable object.

The starting index is inclusive and the ending index is exclusive. That means that every position corresponding to a number in between the starting index and the ending index will be included and the starting index position is included, but the ending index position is not included.

Here's a really cool [suggested resource about slicing](https://towardsdatascience.com/the-basics-of-indexing-and-slicing-python-lists-2d12c90a94cf) with examples and visuals.
  * Terms within this resource that you are not expected to understand include "list comprehension" and "numpy Arrays" and "pandas DataFrames". 
  * Another term within this resource, `for` loops, will be explained in the next section of this module.

#### `for` loops

`for` loops are a very commonly used tool for iterating in Python and are often necessary when processing file inputs. 

A `for` loop has several components.
1. The `for` statement
2. The body of the `for` loop
3. Any variable initialization before the `for` statement

The first two of these three components are part of every `for` loop. The last component is only sometimes required. We'll begin by discussing the `for` statement and the body of the `for loop` and then will provide examples of loops that have variable initialization before the statement and those that do not. 

##### `for` statement

The `for` statement has 5 parts to it, in order:
1. the word `for`
2. the variable name for whatever is being extracted within each iteration or step of the `for` loop
3. the word `in`
4. the iterable variable name for the variable from which something is being extracted within each iteration or step of the `for` loop
5. A colon, `:`

There 3 common `for` statement patterns in python. Try to connect the 5 parts of the `for` statement to these patterns.

1. `for value_from_iterable_variable in some_iterable_variable:`

  This statement uses the above pattern (its setup broken down below) in order to work with the items contained in a collection of items item-by-item.
  1. the word `for`
  2. then names the variable that each item from the `some_iterable_variable` will be stored in: `value_from_iterable_variable`
  3. the `in` membership operator, not to check containment like the expressions we saw previously, but to specify that we want items contained in the `some_iterable_variable`
  4. the name of the variable for the collection over which we want to iterate and extract its items item-by-item: `some_iterable_variable`
  5. A colon, `:`

2. `for index in range(len(some_iterable_variable_name)):` or `for index in range(some_integer):`
  
  The `range()` function is a built-in Python function that is used to return a list of numbers from 0 up to, but not including some integer number. You would use this above statement pattern  (its setup broken down below) in order to work with the ordered position numbers rather than the items themselves that are stored in a collection of items. With indexing, you could still access the items item-by-item, but the variable name for whatever is being extracted is storing integers, the index positions, not the items.
  1. the word `for`
  2. then names the variable that each item from the `range()` function will be stored in: `index`
  3. the `in` membership operator to specify that we want items contained in the list the `range()` function returns
  4. the `range()` function that returns a list of numbers either specified by the `len()` function and the length of `some_iterable_variable_name` or just some integer value (`some_integer`)
  5. A colon, `:`


3. `for index, value_from_iterable_variable in enumerate(some_iterable_variable_name):`

This third statement is a combination of the first two statements where for each iteration or step in the `for` loop, you have access to both the value and the index of the value from the iterable variable at the same time. This is achieved because the pattern uses a special base python function `enumerate()`. You can [read more about this function from the online python manual](https://docs.python.org/3/library/functions.html#enumerate), but suffice it to say that the function takes in an iterable object like a list or a string. Then rather than just returning the elements of the iterable object, it also returns the corresponding indices enumerated or counted out for each of the elements in the iterable object. 

For example, if we have a list `test_list = ["daisy", "poppy", "daylily", "sunflower", "begonia"]`. In a `for` loop statement following the first pattern, `for flower in test_list:`, only elements from the list are returned, specifically to the variable `flower`. And the `flower` variable will be "daisy" in the first iteration of the for loop, "poppy" in the second iteration, "daylily" in the third iteration, "sunflower" in the fourth, and finally "begonia" in the fifth. If we instead follow the third pattern and use the `enumerate` function, specifically, `for index, flower in enumerate(test_list)`, the `flower` variable will take on the same values for each iteration of the loop as the first pattern example. The `index` variable will take on the values `0`, `1`, `2`, `3`, and `4` respectively.


  The setup is broken down below for this pattern
  1. the word `for`
  2. the names the variables that each index and each item from the `some_iterable_variable_name` will be stored in: `index`, `value_from_iterable_variable`
  3. the `in` membership operator to specify that we want items contained in the output from `enumerate()`
  4. the `enumerate()` function with the `some_iterable_variable_name` over which we want to extract items and their indexes item-by-item.
  5. A colon, `:`


##### `for` loop body

**Indentation**

The `for` loop body is going to be indented below the `for` loop statement. This is necessary because indenting tells Python what is done as part of the `for` loop, and when to re-start the next iteration of the `for` loop.

As an example, consider this for loop: 

```{python}
dogowners = ["Kate", "Dylan" ,"Mike", "Andrew"]
for index, dogname in enumerate(["Gibbs", "Chela", "Barnaby", "Duke"]):
  print("The owner of", dogname, "is", dogowners[index])
print("What other information should we share about these dogs? Size? Breed? Favorite toy?")
```

First, notice that the print statement that is indented under the `for` statement will be printed four time, each one with a different dog name, and a different dog owner's name. But the print statement that is not indented under the `for` statement, and instead is aligned with it, will only be executed once, after the other 4 lines have printed and the `for` loop is complete.

Second, let's go back a step and break down the pattern of the `for` statement.
* Which pattern of the 3 was used?
* Why do you think that pattern was used?
* Is there another pattern that could have been used as effectively? 

Like with conditional statement, the order of execution within the body of the loop (all lines that are indented) follows a downwards linear pattern. Lines listed earlier/first will be executed first and lines listed later will be executed later. Once every iteration of the `for` loop is complete, then lines outside of the `for` loop will be executed, like how the final print statement that asks what other dog innformation should be shared is only displayed after the `for` loop body is complete.

##### initializing variables before the `for` loop

An example of when you might want to initialzie variables before the `for` loop that will be edited within the `for` loop body is when you may want to count how many times a condition is met within a `for` loop. In such a case, you would initialize a variable before the for loop and then add one to the counter within the `for` loop body every time the condition is met.

This condition could be as simple as number of times the for loop iterates and so you add one to the counter every single iteration:

```{python}
dow = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
counter = 0
for day_of_week in dow:
  counter = counter + 1
print(counter)
```

Or it may be more complex, like seeing if the day of the week starts with the letter T or S. Here we'll use the first pattern for the `for` statement because we'll want to have access to the actual day of the week name, and then within the `for` loop body, we'll use an if statement with two expressions returning True or False and an `or` logical operator between the two expressions. To see if the day of the week starts with the letter T or S, we'll use a python built-in function `startswith()`. Note that we're re-initializing the `counter` variable to 0 outside of the `for` loop and adding one every time the a or b expression evaluates to True.

```{python}
counter = 0
for day_of_week in dow:
  if day_of_week.startswith("T") or day_of_week.startswith("S"):
    counter = counter + 1
print(counter)
```

##### Pseudo-coding a for loop

When writing pseudo-code and knowing that you'll need to use a `for` loop, we find that it's easiest to go back to the basic structure of a `for` loop.

1. Start by filling in your `for` statement
  * Write the `for`, `in`, and `:` and leave blanks for what you're extracting information from (part 5) and what you're extracting (part 3)
  * Then start on part 5. 
    * Add in the variable name for what you're extracting information from
    * Do you want to index or just extract a value or do both?
  * Then fill in informative variable names for part 3 of the `for` statement
2. Outline in words what you want to do within the `for` loop body
  * remember to indent what should be done for each iteration of the loop
  * use your `for` statement part 3 variable names as much as possible within this outline
  * remember that order matters and the steps are going to be executed sequentially within the loop.

### Adding comments to code

We can add comments to our code to explain what we are doing or what we want to do using a pound sign or the hash (`#`). You can either start a line with this or put it at the end of the line. Everything on the line after the pound sign (`#`) will be ignored by python and not executed, but allows readers of code to better understand what is happening. It's also helpful to remind you as a programmer when you look back at an old script what you intended.

### Importing packages (AKA libraries or modules)

Finally, sometimes in Python we'll use the `import()` function to import packages that have pre-built functions that aren't built-in python functions, but nonetheless allow us to do specific things. A very common package that we'll be using in this prep work is `sys` which allows us to take in commandline arguments when calling a bash script on Python. For plotting we would use a package called `matplotlib.pyplot`. 



